

==== app\Models\BillOfMaterial.php ====

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class BillOfMaterial extends Model
{
    use HasFactory;

    protected $table = 'bills_of_material';

    protected $fillable = [
        'product_id',
        'part_id',
        'quantity_required',
    ];

    public function product(): BelongsTo
    {
        return $this->belongsTo(Product::class);
    }

    public function part(): BelongsTo
    {
        return $this->belongsTo(Part::class);
    }
}


==== app\Models\Brand.php ====

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Brand extends Model
{
    use HasFactory;
}


==== app\Models\Catalog.php ====

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Str;
use Illuminate\Database\Eloquent\Relations\HasMany;
use App\Models\User;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Catalog extends Model
{
    public $incrementing = false; // Disable auto-incrementing ID since we're using UUID
    protected $keyType = 'string'; // The primary key type is string (UUID)

    protected $fillable = ['channel', 'source'];

    public function getSupplier(string $supplierName)
    {
        return $this->products()->where('supplier', $supplierName)->get();
    }

    public function products(): HasMany
    {
        return $this->hasMany(Product::class);
    }
    /**
     * Boot function to generate UUID on model creation.
     */
    protected static function boot()
    {
        parent::boot();
        static::creating(function ($model) {
            if (empty($model->{$model->getKeyName()})) {
                $model->{$model->getKeyName()} = (string) Str::uuid(); // Generate UUID
            }
        });
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
}


==== app\Models\Dimension.php ====

<?php

namespace App\Models;

use App\Enums\DimensionType;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\ModelNotFoundException;
use Illuminate\Database\Eloquent\Relations\MorphToMany;
use Illuminate\Support\Facades\Log;

class Dimension extends Model
{
    use HasFactory;

    protected $fillable = [
        'length',
        'width',
        'height',
        'unit',
        'type',
        'volume',
    ];

    protected $casts = [
        'type' => DimensionType::class,
    ];

    protected static function booted()
    {
        static::saving(function ($dimension) {
            $dimension->calculateVolume();
        });
    }

    public function calculateVolume(): void
    {
        try {
            $this->volume = $this->length * $this->width * $this->height;
        } catch (\Exception $e) {
            Log::error('Error calculating volume: ' . $e->getMessage());
        }
    }

    public function getFormattedDimensionsAttribute(): string
    {
        return "{$this->length} x {$this->width} x {$this->height} {$this->unit}";
    }

    public function scopeOfType($query, DimensionType $type)
    {
        return $query->where('type', $type->value);
    }

    public static function findByAttributesOrFail(array $attributes)
    {
        $query = static::query();

        foreach ($attributes as $key => $value) {
            $query->where($key, $value);
        }

        $result = $query->first();

        if (! $result) {
            throw (new ModelNotFoundException)->setModel(
                static::class,
                array_values($attributes)
            );
        }

        return $result;
    }

    public static function findByDimensionsOrFail(array $dimensions, ?string $unit = null)
    {
        if (count($dimensions) !== 3) {
            throw new \InvalidArgumentException('Dimensions array must contain exactly 3 values [L, W, H]');
        }

        [$length, $width, $height] = $dimensions;

        $query = static::query()
            ->where('length', $length)
            ->where('width', $width)
            ->where('height', $height);

        if ($unit !== null) {
            $query->where('unit', $unit);
        }

        $result = $query->first();

        if (! $result) {
            throw (new ModelNotFoundException)->setModel(
                static::class,
                [$length, $width, $height, $unit]
            );
        }

        return $result;
    }

    public function parts(): MorphToMany
    {
        return $this->morphedByMany(Part::class, 'dimensionable')->withPivot('dimensionable_type');
    }

    public function products(): MorphToMany
    {
        return $this->morphedByMany(Product::class, 'dimensionable')->withPivot('dimensionable_type');
    }

    public function morphedByMany($related, $name, $table = null, $foreignPivotKey = null, $relatedPivotKey = null, $parentKey = null, $relatedKey = null, $inverse = false)
    {
        $relation = parent::morphedByMany($related, $name, $table, $foreignPivotKey, $relatedPivotKey, $parentKey, $relatedKey, $inverse);

        $relation->withPivot('dimensionable_type');

        return $relation;
    }
}


==== app\Models\Gtin.php ====

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Gtin extends Model
{
    use HasFactory;

    protected $fillable = ['gtin', 'status', 'lease_end_date', 'product_id'];

    protected $casts = [
        'gtin' => 'string',
        'status' => 'string',
        'lease_end_date' => 'date',
    ];

    public function product(): BelongsTo
    {
        return $this->belongsTo(Product::class);
    }
}


==== app\Models\Inventory.php ====

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Inventory extends Model
{
    use HasFactory;

    protected $fillable = [
        'location_id',
        'inventoryable_id',
        'inventoryable_type',
        'quantity_onhand',
        'quantity_intransit',
        'quantity_backordered',
        'quantity_allocated',
        'quantity_reserved',
        'version',
    ];

    protected $casts = [
        'quantity_onhand' => 'integer',
        'quantity_intransit' => 'integer',
        'quantity_backordered' => 'integer',
        'quantity_allocated' => 'integer',
        'quantity_reserved' => 'integer',
        'version' => 'integer',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    public static function boot()
    {
        parent::boot();

        static::updating(function ($model) {
            if ($model->isDirty('version')) {
                throw new \Exception('This inventory has been modified. Please retry the operation.');
            }
            $model->version++;
        });
    }

    public function inventoryable()
    {
        return $this->morphTo();
    }

    public function location()
    {
        return $this->belongsTo(Location::class);
    }

    /**
     * Get the total available quantity.
     *
     * @return int
     */
    public function getAvailableQuantityAttribute()
    {
        return $this->quantity_onhand - $this->quantity_allocated - $this->quantity_reserved;
    }

    /**
     * Get the total quantity.
     *
     * @return int
     */
    public function getTotalQuantityAttribute()
    {
        return $this->quantity_onhand + $this->quantity_intransit;
    }
}


==== app\Models\InventoryTransaction.php ====

<?php

namespace App\Models;

use App\InventoryTransactions\Enums\TransactionType;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Support\Str;

class InventoryTransaction extends Model
{
    use HasFactory;

    protected $fillable = [
        'ulid',
        'batch_id',
        'inventoryable_type',
        'inventoryable_id',
        'quantity',
        'transaction_type',
        'from_location_id',
        'to_location_id',
        'reason',
        'user_id',
    ];

    protected $casts = [
        'quantity' => 'integer',
        'transaction_type' => TransactionType::class,
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    protected $appends = ['action'];

    public function addTransaction(InventoryTransaction $transaction): void
    {
        $transaction->batch_id = $this->id;
        $transaction->save();
    }

    protected static function boot()
    {
        parent::boot();

        static::creating(function ($model) {
            $model->ulid = $model->ulid ?? (string) Str::ulid();
        });
    }

    public function isDeduction(): bool
    {
        return in_array($this->transaction_type, [
            TransactionType::ISSUE,
            TransactionType::TRANSFER,
            TransactionType::ALLOCATE,
            TransactionType::RESERVE,
        ]);
    }

    public function isAddition(): bool
    {
        return in_array($this->transaction_type, [
            TransactionType::RECEIPT,
            TransactionType::RETURN,
        ]);
    }

    public function isNeutral(): bool
    {
        return in_array($this->transaction_type, [
            TransactionType::ADJUSTMENT,
            TransactionType::CYCLE_COUNT,
            TransactionType::BACKORDER,
        ]);
    }

    public function getActionAttribute(): string
    {
        return $this->transaction_type->value;
    }

    public function batch(): BelongsTo
    {
        return $this->belongsTo(InventoryTransactionBatch::class, 'batch_id');
    }

    public function inventoryable()
    {
        return $this->morphTo();
    }

    public function fromLocation(): BelongsTo
    {
        return $this->belongsTo(Location::class, 'from_location_id');
    }

    public function toLocation(): BelongsTo
    {
        return $this->belongsTo(Location::class, 'to_location_id');
    }

    public function user()
    {
        return $this->belongsTo(User::class);
    }
}


==== app\Models\InventoryTransactionBatch.php ====

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Support\Str;

class InventoryTransactionBatch extends Model
{
    use HasFactory;

    const STATUS_PENDING = 'pending';

    const STATUS_PROCESSING = 'processing';

    const STATUS_COMPLETED = 'completed';

    const STATUS_FAILED = 'failed';

    protected $fillable = [
        'ulid',
        'description',
        'status',
        'reference_type',
        'reference_id',
        'user_id',
    ];

    protected $casts = [
        'ulid' => 'string',
        'description' => 'string',
        'status' => 'string',
    ];

    public function addTransaction(InventoryTransaction $transaction): void
    {
        $transaction->batch_id = $this->id;
        $transaction->save();
    }

    protected static function boot()
    {
        parent::boot();

        static::creating(function ($model) {
            $model->ulid = $model->ulid ?? (string) Str::ulid();
        });
    }

    public function reference()
    {
        return $this->morphTo();
    }

    public function transactions(): HasMany
    {
        return $this->hasMany(InventoryTransaction::class, 'batch_id');
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function markAsProcessing(): void
    {
        $this->update(['status' => self::STATUS_PROCESSING]);
    }

    public function markAsCompleted(): void
    {
        $this->update([
            'status' => self::STATUS_COMPLETED,
            'processed_at' => now(),
        ]);
    }

    public function markAsFailed(): void
    {
        $this->update(['status' => self::STATUS_FAILED]);
    }

    public function isPending(): bool
    {
        return $this->status === self::STATUS_PENDING;
    }

    public function isProcessing(): bool
    {
        return $this->status === self::STATUS_PROCESSING;
    }

    public function isCompleted(): bool
    {
        return $this->status === self::STATUS_COMPLETED;
    }

    public function isFailed(): bool
    {
        return $this->status === self::STATUS_FAILED;
    }
}


==== app\Models\Location.php ====

<?php

namespace App\Models;

use App\DTOs\LocationAddressesDTO;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Validation\ValidationException;

class Location extends Model
{
    use HasFactory;

    const TYPE_WAREHOUSE = 'warehouse';
    const TYPE_SUPPLIER = 'supplier';
    const TYPE_RACK = 'rack';
    const TYPE_BIN = 'bin';
    const TYPE_VIRTUAL = 'virtual';

    const VIRTUAL_TYPE_BILL_TO = 'bill_to';
    const VIRTUAL_TYPE_SHIP_TO = 'ship_to';
    const VIRTUAL_TYPE_WORK_ORDER = 'work_order';

    protected $fillable = [
        'name',
        'virtual_type',
        'addresses',
        'type',
        'parent_id',
        'supplier_id',
    ];

    protected $casts = [
        'addresses' => LocationAddressesDTO::class,
    ];

    protected static $hierarchyMap = [
        self::TYPE_WAREHOUSE => null,
        self::TYPE_SUPPLIER => null,
        self::TYPE_RACK => self::TYPE_WAREHOUSE,
        self::TYPE_BIN => self::TYPE_RACK,
        self::TYPE_VIRTUAL => [self::TYPE_WAREHOUSE, self::TYPE_SUPPLIER],
    ];

    protected static function boot()
    {
        parent::boot();

        static::saving(function ($location) {
            $location->validateHierarchy();
        });
    }

    public function parent(): BelongsTo
    {
        return $this->belongsTo(Location::class, 'parent_id');
    }

    public function children(): HasMany
    {
        return $this->hasMany(Location::class, 'parent_id');
    }

    public function supplier(): BelongsTo
    {
        return $this->belongsTo(Supplier::class);
    }

    protected function validateHierarchy()
    {
        $allowedParentType = self::$hierarchyMap[$this->type] ?? null;

        if ($allowedParentType === null && $this->parent_id !== null) {
            throw ValidationException::withMessages([
                'parent_id' => ucfirst($this->type) . ' cannot have a parent location.',
            ]);
        }

        if ($allowedParentType !== null && $this->parent_id === null) {
            $errorMessage = $this->getParentTypeErrorMessage($allowedParentType);
            throw ValidationException::withMessages([
                'parent_id' => $errorMessage,
            ]);
        }

        if ($allowedParentType !== null && $this->parent) {
            $isValidParent = is_array($allowedParentType)
                ? in_array($this->parent->type, $allowedParentType)
                : $this->parent->type === $allowedParentType;

            if (!$isValidParent) {
                $errorMessage = $this->getParentTypeErrorMessage($allowedParentType);
                throw ValidationException::withMessages([
                    'parent_id' => $errorMessage,
                ]);
            }
        }
    }

    protected function getParentTypeErrorMessage($allowedParentType): string
    {
        if (is_array($allowedParentType)) {
            $parentTypes = array_map('ucfirst', $allowedParentType);
            return ucfirst($this->type) . ' must have a ' . implode(' or ', $parentTypes) . ' as parent.';
        }
        return ucfirst($this->type) . ' must have a ' . ucfirst($allowedParentType) . ' as parent.';
    }

    public static function getValidTypes(): array
    {
        return [
            self::TYPE_WAREHOUSE,
            self::TYPE_RACK,
            self::TYPE_BIN,
            self::TYPE_VIRTUAL,
            self::TYPE_SUPPLIER,
        ];
    }

    public static function getValidVirtualTypes(): array
    {
        return [
            self::VIRTUAL_TYPE_BILL_TO,
            self::VIRTUAL_TYPE_SHIP_TO,
            self::VIRTUAL_TYPE_WORK_ORDER,
        ];
    }

    public function inventory(): HasMany
    {
        return $this->hasMany(Inventory::class);
    }

    public function purchaseOrders(): HasMany
    {
        return $this->hasMany(PurchaseOrder::class);
    }

    public function billToPurchaseOrders(): HasMany
    {
        return $this->hasMany(PurchaseOrder::class, 'bill_to_location_id');
    }

    public function supplierPurchaseOrders(): HasMany
    {
        return $this->hasMany(PurchaseOrder::class, 'supplier_location_id');
    }

    public function shipFromPurchaseOrders(): HasMany
    {
        return $this->hasMany(PurchaseOrder::class, 'ship_from_location_id');
    }
}


==== app\Models\Manufacturer.php ====

<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Manufacturer extends Model
{
    use HasFactory;

    protected $fillable = ['name'];

    public function parts(): HasMany
    {
        return $this->hasMany(Part::class);
    }
}


==== app\Models\Part.php ====

<?php

namespace App\Models;

use App\Concerns\HasDimensions;
use App\DTOs\ReplenishmentDataDTO;
use App\DTOs\IdentifierDTO;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Spatie\LaravelData\Attributes\DataCollectionOf;

class Part extends Model
{
    use HasDimensions, HasFactory;

    protected $fillable = [
        'part_number',
        'quantity',
        'uom',
        'description',
        'identifiers',
        'regulatory_information',
        'replenishment_data',
        'manufacturer_id',
        'supplier_id',
        'lead_time_days',
    ];

    protected $casts = [
        'identifiers' => IdentifierDTO::class,
        'regulatory_information' => IdentifierDTO::class,
        'quantity' => 'integer',
        'replenishment_data' => ReplenishmentDataDTO::class,
    ];

    public function products(): BelongsToMany
    {
        return $this->belongsToMany(Product::class, 'bills_of_material')
            ->withPivot('quantity_required')
            ->withTimestamps();
    }

    public function supplier(): BelongsTo
    {
        return $this->belongsTo(Supplier::class);
    }

    public function manufacturer(): BelongsTo
    {
        return $this->belongsTo(Manufacturer::class);
    }

    public function getUnitCostAttribute()
    {
        return $this->replenishment_data->purchaseTerms[0]['cost_per_part'] ?? 0;
    }

    public function getIdentifierValue(string $type): ?string
    {
        return $this->identifiers->identifiers->firstWhere('type', $type)?->value;
    }

    public function getRegulatoryInformationValue(string $type): ?string
    {
        return $this->regulatory_information->identifiers->firstWhere('type', $type)?->value;
    }
}


==== app\Models\Post.php ====

<?php

namespace App\Models;

use App\Filament\Resources\PostResource;
use Awcodes\Curator\Models\Media;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Arr;
use Illuminate\Support\Str;

class Post extends Model
{
    use HasFactory;

    /**
     * The attributes that are mass assignable.
     *
     * @var array
     */
    protected $fillable = [
        'title',
        'slug',
        'content',
        'image_id',
        'user_id',
        'is_published',
        'published_at',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array
     */
    protected $casts = [
        'content' => 'array',
        'is_published' => 'boolean',
        'published_at' => 'datetime',
    ];

    /**
     * Get the user that owns the post.
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Get the featured image for the post.
     *
     * @return \Illuminate\Database\Eloquent\Relations\BelongsTo
     */
    public function image()
    {
        return $this->belongsTo(Media::class);
    }

    /**
     * Retrieve the post URL.
     *
     * @return string
     */
    public function getUrlAttribute()
    {
        return route('post.show', $this);
    }

    /**
     * Retrieve the post edit URL.
     *
     * @return string
     */
    public function getEditUrlAttribute()
    {
        return PostResource::getUrl('edit', ['record' => $this]);
    }

    /**
     * Retrieve the post content blocks as an object.
     *
     * @return object
     */
    public function getBlocksAttribute()
    {
        return json_decode(
            collect($this->content ?? [])->toJson()
        );
    }

    /**
     * Retrieve the post excerpt.
     *
     * @return string
     */
    public function getExcerptAttribute()
    {
        $excerpt = collect($this->content)
            ->where('type', 'markdown')
            ->first() ?? [];

        $excerpt = collect(
            explode("\n", Arr::get($excerpt, 'data.content', ''))
        )->first();

        return Str::limit($excerpt, 160);
    }

    /**
     * Retrieve the published posts.
     *
     * @param  \Illuminate\Database\Eloquent\Builder  $query
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopePublished($query)
    {
        return $query->where('is_published', true);
    }

    /**
     * Retrieve the draft posts.
     *
     * @param  \Illuminate\Database\Eloquent\Builder  $query
     * @return \Illuminate\Database\Eloquent\Builder
     */
    public function scopeDrafts($query)
    {
        return $query->where('is_published', false);
    }
}


==== app\Models\Product.php ====

<?php

namespace App\Models;

use App\Concerns\HasDimensions;
use App\DTOs\IdentifierDTO;
use App\DTOs\ReplenishmentDataDTO;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;

class Product extends Model
{
    use HasDimensions, HasFactory;

    protected $fillable = [
        'name',
        'description',
        'identifiers',
        'replenishment_data',
        'weight_oz'
    ];

    protected $casts = [
        'identifiers' => IdentifierDTO::class,
        'replenishment_data' => ReplenishmentDataDTO::class,
        'weight_oz' => 'decimal'
    ];

    public function parts(): BelongsToMany
    {
        return $this->belongsToMany(Part::class, 'bills_of_material')
            ->withPivot('quantity_required')
            ->withTimestamps();
    }

    public function billOfMaterials(): HasMany
    {
        return $this->hasMany(BillOfMaterial::class);
    }

    public function gtin(): HasOne
    {
        return $this->hasOne(Gtin::class);
    }

    public function getMasterSku(): ?string
    {
        return $this->getIdentifierValue('master_sku');
    }

    public function getIdentifierValue(string $type): ?string
    {
        return $this->identifiers->identifiers->firstWhere('type', $type)?->value;
    }

    public function getDisplayName(): string
    {
        return $this->getMasterSku() ?? $this->name ?? '';
    }
}


==== app\Models\PurchaseOrder.php ====

<?php

namespace App\Models;

use App\DTOs\AddressDTO;
use App\Enums\PurchaseOrderStatus;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class PurchaseOrder extends Model
{
    use HasFactory, SoftDeletes;

    protected $fillable = [
        'number',
        'supplier_id',
        'location_id',
        'status',
        'total_cost',
        'user_id',
        'opened_at',
        'closed_at',
        'bill_to_address_index',
        'ship_from_address_index',
        'ship_to_address_index',
    ];

    protected $casts = [
        'status' => PurchaseOrderStatus::class,
        'total_cost' => 'decimal:2',
        'opened_at' => 'datetime',
        'closed_at' => 'datetime',
        'bill_to_address_index' => 'integer',
        'ship_from_address_index' => 'integer',
        'ship_to_address_index' => 'integer',
    ];

    protected $appends = ['bill_to_address', 'ship_from_address', 'ship_to_address'];

    protected static function booted()
    {
        static::creating(function ($purchaseOrder) {
            if (!$purchaseOrder->number) {
                $purchaseOrder->number = static::getPurchaseOrderNumber();
            }
        });

        static::saving(function ($purchaseOrder) {
            $purchaseOrder->updateTotalCost();
        });
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function supplier(): BelongsTo
    {
        return $this->belongsTo(Supplier::class);
    }

    public function location(): BelongsTo
    {
        return $this->belongsTo(Location::class);
    }

    public function purchaseOrderParts(): HasMany
    {
        return $this->hasMany(PurchaseOrderPart::class);
    }

    public function getBillToAddressAttribute(): ?AddressDTO
    {
        return $this->supplier->addresses->billTo[$this->bill_to_address_index] ?? null;
    }

    public function getShipFromAddressAttribute(): ?AddressDTO
    {
        return $this->supplier->addresses->shipFrom[$this->ship_from_address_index] ?? null;
    }

    public function getShipToAddressAttribute(): ?AddressDTO
    {
        return $this->location->addresses->shipTo[$this->ship_to_address_index] ?? null;
    }

    public function setStatus(PurchaseOrderStatus $status): self
    {
        $this->status = $status;
        return $this;
    }

    public function calculateTotalCost(): float
    {
        return $this->purchaseOrderParts->sum('total_cost');
    }

    public function updateTotalCost(): void
    {
        $this->total_cost = $this->calculateTotalCost();
    }

    public static function getPurchaseOrderNumber(): int
    {
        $lastPO = static::orderBy('number', 'desc')->first();

        if ($lastPO) {
            $newNumber = $lastPO->number + 1;
        } else {
            $newNumber = 1;
        }

        return $newNumber;
    }

    public function isEditable(): bool
    {
        return in_array($this->status, [
            PurchaseOrderStatus::DRAFT,
            PurchaseOrderStatus::SUBMITTED,
        ]);
    }
}


==== app\Models\PurchaseOrderPart.php ====

<?php

namespace App\Models;

use App\Enums\PurchaseOrderStatus;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class PurchaseOrderPart extends Model
{
    use HasFactory;
    protected $table = 'purchase_order_parts';
    protected $fillable = [
        'purchase_order_id',
        'part_id',
        'quantity_ordered',
        'unit_cost',
        'total_cost',
        'quantity_invoiced',
        'quantity_received',
        'notes',
    ];

    protected $casts = [
        'quantity_ordered' => 'integer',
        'unit_cost' => 'decimal:2',
        'total_cost' => 'decimal:2',
        'quantity_invoiced' => 'integer',
        'quantity_received' => 'integer',
    ];

    protected static function booted()
    {
        static::saving(function ($purchaseOrderPart) {
            $purchaseOrderPart->calculateTotalCost();
        });

        static::saved(function ($purchaseOrderPart) {
            $purchaseOrderPart->purchaseOrder->updateTotalCost();
        });
    }

    public function purchaseOrder(): BelongsTo
    {
        return $this->belongsTo(PurchaseOrder::class);
    }

    public function part(): BelongsTo
    {
        return $this->belongsTo(Part::class);
    }

    public function calculateTotalCost(): void
    {
        $this->total_cost = $this->quantity_ordered * $this->unit_cost;
    }

    public function getRemainingQuantityAttribute(): int
    {
        return $this->quantity_ordered - $this->quantity_received;
    }

    public function getStatusAttribute(): PurchaseOrderStatus
    {
        if ($this->quantity_received === 0) {
            return PurchaseOrderStatus::SUBMITTED;
        } elseif ($this->quantity_received < $this->quantity_ordered) {
            return PurchaseOrderStatus::PARTIALLY_RECEIVED;
        } else {
            return PurchaseOrderStatus::FULLY_RECEIVED;
        }
    }

    public function scopeSubmitted($query)
    {
        return $query->where('quantity_received', 0);
    }

    public function scopeReceived($query)
    {
        return $query->where('quantity_received', '>', 0);
    }

    public function scopeFullyReceived($query)
    {
        return $query->whereRaw('quantity_received = quantity_ordered');
    }

    public function scopePartiallyReceived($query)
    {
        return $query->whereRaw('quantity_received > 0 AND quantity_received < quantity_ordered');
    }

    protected static function newFactory()
    {
        return \Database\Factories\PurchaseOrderPartFactory::new();
    }
}


==== app\Models\Supplier.php ====

<?php

namespace App\Models;

use App\DTOs\AddressDTO;
use App\DTOs\SupplierAddressesDTO;
use App\DTOs\IdentifierDTO;
use App\Models\PurchaseOrder;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\SoftDeletes;

class Supplier extends Model
{
    use HasFactory, SoftDeletes;

    protected $fillable = [
        'name',
        'account_number',
        'payment_terms',
        'lead_time_days',
        'free_shipping_threshold_usd',
        'contact',
        'addresses',
        'identifiers',
    ];

    protected $casts = [
        'lead_time_days' => 'integer',
        'free_shipping_threshold_usd' => 'decimal:2',
        'contact' => 'json',
        'addresses' => SupplierAddressesDTO::class,
        'identifiers' => IdentifierDTO::class,
    ];

    protected $appends = ['free_shipping'];

    protected $with = ['parts', 'locations'];

    public function getFreeShippingAttribute(): bool
    {
        return $this->free_shipping_threshold_usd !== null && $this->free_shipping_threshold_usd >= 0;
    }

    public function setFreeShippingThresholdUsdAttribute($value)
    {
        $this->attributes['free_shipping_threshold_usd'] = $value !== null ? max(0, $value) : null;
    }

    public function parts(): HasMany
    {
        return $this->hasMany(Part::class);
    }

    public function locations(): HasMany
    {
        return $this->hasMany(Location::class);
    }

    public function purchaseOrders(): HasMany
    {
        return $this->hasMany(PurchaseOrder::class);
    }

    // Helper functions for addresses

    /**
     * @return array
     */
    public function getBillToAddresses(): array
    {
        return $this->addresses->billTo?->toArray() ?? [];
    }

    /**
     * @return array
     */
    public function getShipFromAddresses(): array
    {
        return $this->addresses->shipFrom?->toArray() ?? [];
    }

    /**
     * @return array
     */
    public function getShipToAddresses(): array
    {
        return $this->addresses->shipTo?->toArray() ?? [];
    }

    /**
     * @return array
     */
    public function getReturnToAddresses(): array
    {
        return $this->addresses->returnTo?->toArray() ?? [];
    }

    public function getBillToAddress(int $index = 0): ?array
    {
        $addresses = $this->getBillToAddresses();
        return $addresses[$index] ?? null;
    }

    public function getShipFromAddress(int $index = 0): ?array
    {
        $addresses = $this->getShipFromAddresses();
        return $addresses[$index] ?? null;
    }

    public function getShipToAddress(int $index = 0): ?array
    {
        $addresses = $this->getShipToAddresses();
        return $addresses[$index] ?? null;
    }

    public function getReturnToAddress(int $index = 0): ?array
    {
        $addresses = $this->getReturnToAddresses();
        return $addresses[$index] ?? null;
    }
}


==== app\Models\User.php ====

<?php

namespace App\Models;

// use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;

class User extends Authenticatable
{
    use HasFactory;
    use Notifiable;

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'name',
        'email',
        'password',
    ];

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var array<int, string>
     */
    protected $hidden = [
        'password',
        'remember_token',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'email_verified_at' => 'datetime',
            'password' => 'hashed',
        ];
    }

    public function catalogs(): HasMany
    {
        return $this->hasMany(Catalog::class);
    }
}


==== resources\js\Interfaces\AddressDTO.ts ====

import { App } from '../Models/types';

export type AddressDTO = App.DTOs.AddressDTO;


==== resources\js\Models\generated.d.ts ====

declare namespace App.DTOs {
  export type AddressDTO = {
    address1: string | null;
    address2: string | null;
    city: string | null;
    state_prov_code: string | null;
    zip: string | null;
    phone_number: string | null;
    email_address: string | null;
  };

  export type IdentifierDTO = {
    identifiers: Array<any>;
  };

  export type IdentifierData = {
    type: string | null;
    value: string | null;
  };

  export type LocationAddressesDTO = {
    billTo: any | null;
    shipFrom: any | null;
    shipTo: any | null;
    other: any | null;
  };

  export type ReplenishmentDataDTO = {
    lead_days: number;
    purchaseTerms: Array<any>;
  };

  export type SupplierAddressesDTO = {
    billTo: any | null;
    shipFrom: any | null;
    shipTo: any | null;
    returnTo: any | null;
  };
}

declare namespace App.Enums {
  export type DimensionType = 'box' | 'pallet' | 'individual_unit' | 'product' | 'packaging';
  export type InventoryQuantityType = 'quantity_onhand' | 'quantity_allocated' | 'quantity_backordered' | 'quantity_reserved' | 'quantity_intransit';
  export type PurchaseOrderStatus = 'draft' | 'submitted' | 'approved' | 'partially_received' | 'fully_received' | 'closed' | 'cancelled';
}

declare namespace App.Enums.Replenishment {
  export type RecommendedAction = 'None' | 'Reorder' | 'Restock' | 'Hold';
}

declare namespace App.InventoryTransactions.Enums {
  export type TransactionSourceType = 'purchase_order' | 'sales_order' | 'internal_transfer' | 'adjustment' | 'production' | 'return' | 'cycle_count';
  export type TransactionType = 'adjustment' | 'transfer' | 'receipt' | 'issue' | 'return' | 'cycle_count' | 'allocate' | 'reserve' | 'backorder';
}


==== resources\js\Models\index.ts ====

export * from './Model';
export * from './Supplier';
export * from './Location';
export * from './PurchaseOrder';
export * from './PurchaseOrderPart';
export * from './User';
export * from './Part';
export * from './Inventory';
export * from './types'


==== resources\js\Models\Inventory.ts ====

import { Model, Location } from './index';

export class Inventory extends Model {
  declare id: number;
  declare location_id: number;
  declare inventoryable_id: number;
  declare inventoryable_type: string;
  declare quantity: number;
  declare available_quantity: number;
  declare total_quantity: number;

  // Relationships
  declare location?: Location;
  declare inventoryable?: any; // This could be Part or Product, depending on the polymorphic relationship

  $attributes: {
    id: number;
    location_id: number;
    inventoryable_id: number;
    inventoryable_type: string;
    quantity: number;
    available_quantity: number;
    total_quantity: number;
  };

  constructor(data?: Partial<Inventory>) {
    super(data);
    this.$attributes = {
      id: this.id,
      location_id: this.location_id,
      inventoryable_id: this.inventoryable_id,
      inventoryable_type: this.inventoryable_type,
      quantity: this.quantity,
      available_quantity: this.available_quantity,
      total_quantity: this.total_quantity
    };
  }

  // Implement Orion-specific query methods
  static includes(): string[] {
    return ['location', 'inventoryable'];
  }

  static filterableBy(): string[] {
    return ['id', 'location_id', 'inventoryable_id', 'inventoryable_type', 'quantity', 'available_quantity', 'total_quantity'];
  }

  static sortableBy(): string[] {
    return ['id', 'location_id', 'inventoryable_id', 'inventoryable_type', 'quantity', 'available_quantity', 'total_quantity'];
  }

  static searchableBy(): string[] {
    return [];
  }

  static $query(): any {
    // This is a placeholder for the Orion query builder
    return {
      get: () => Promise.resolve([]),
      find: (id: number) => Promise.resolve(new Inventory()),
    };
  }

  $resource(): string {
    return 'inventory';
  }
}


==== resources\js\Models\Location.ts ====

import { Model } from '@tailflow/laravel-orion/lib/model';
import { AddressDTO } from '../Interfaces/AddressDTO';

export class Location extends Model<{
  id: number;
  name: string;
  virtual_type: string | null;
  addresses: AddressDTO[];
  type: string;
  parent_id: number | null;
  supplier_id: number | null;
  created_at: string;
  updated_at: string;
}> {
  static $keyName = 'id';

  $resource(): string {
    return 'locations';
  }

  $init(): void {
    // Initialization logic if needed
  }
}


==== resources\js\Models\Manufacturer.ts ====

import { Model } from "@tailflow/laravel-orion/lib/model";
import { HasMany } from "@tailflow/laravel-orion/lib/drivers/default/relations/hasMany";
import { Part } from "./Part";

export class Manufacturer extends Model<{
    id: number;
    name: string;
}, {
    created_at: string;
    updated_at: string;
    deleted_at: string | null;
}, {
    parts: Part[];
}> {
    public $resource(): string {
        return 'manufacturers';
    }

    public parts(): HasMany<Part> {
        return new HasMany(Part, this);
    }
}


==== resources\js\Models\Model.ts ====

export abstract class Model {
  declare id: number;

  constructor(data?: Partial<Model>) {
    Object.assign(this, data);
  }

  static includes(): string[] {
    return [];
  }

  static filterableBy(): string[] {
    return [];
  }

  static sortableBy(): string[] {
    return [];
  }

  static searchableBy(): string[] {
    return [];
  }
}


==== resources\js\Models\Part.ts ====

import { Model } from "@tailflow/laravel-orion/lib/model";
import { BelongsTo } from "@tailflow/laravel-orion/lib/drivers/default/relations/belongsTo";
import { HasMany } from "@tailflow/laravel-orion/lib/drivers/default/relations/hasMany";
import { Supplier } from "./Supplier";
import { Manufacturer } from "./Manufacturer";
import { PurchaseOrderPart } from "./PurchaseOrderPart";

export class Part extends Model<{
    id: number;
    part_number: string;
    quantity: number;
    uom: string;
    description: string;
    identifiers: App.DTOs.IdentifierDTO;
    regulatory_information: App.DTOs.IdentifierDTO;
    replenishment_data: App.DTOs.ReplenishmentDataDTO;
    supplier_id: number;
    manufacturer_id: number;
    created_at: string;
    updated_at: string;
    deleted_at: string | null;
}, {}, {
    supplier: Supplier;
    manufacturer: Manufacturer;
    purchaseOrderParts: PurchaseOrderPart[];
}> {
    public $resource(): string {
        return 'parts';
    }

    public supplier(): BelongsTo<Supplier> {
        return new BelongsTo(Supplier, this);
    }

    public manufacturer(): BelongsTo<Manufacturer> {
        return new BelongsTo(Manufacturer, this);
    }

    public purchaseOrderParts(): HasMany<PurchaseOrderPart> {
        return new HasMany(PurchaseOrderPart, this);
    }

    public getUnitCost(): number {
        if (this.replenishment_data &&
            this.replenishment_data.purchaseTerms &&
            this.replenishment_data.purchaseTerms.length > 0) {
            return this.replenishment_data.purchaseTerms[0].cost_per_part;
        }
        return 0;
    }

    public calculateTotalCost(): number {
        const unitCost = this.getUnitCost();
        return unitCost * this.quantity;
    }

    public updateQuantity(quantity: number): void {
        this.quantity = quantity;
    }

    public getIdentifierValue(type: string): string | null {
        const identifier = this.identifiers.identifiers.find(i => i.type === type);
        return identifier ? identifier.value : null;
    }

    public getRegulatoryInformationValue(type: string): string | null {
        const info = this.regulatory_information.identifiers.find(i => i.type === type);
        return info ? info.value : null;
    }
}


==== resources\js\Models\PurchaseOrder.ts ====

import { Model } from '@tailflow/laravel-orion/lib/model';

export class PurchaseOrder extends Model<{
  id: number;
  number: string;
  supplier_id: number;
  location_id: number;
  status: 'draft' | 'submitted' | 'approved' | 'partially_received' | 'fully_received' | 'closed' | 'cancelled';
  total_cost: number | null;
  user_id: number;
  opened_at: string | null;
  closed_at: string | null;
  bill_to_address_index: number | null;
  ship_from_address_index: number | null;
  ship_to_address_index: number | null;
  created_at: string;
  updated_at: string;
  deleted_at: string | null;
}> {
  static $keyName = 'id';

  $resource(): string {
    return 'purchase-orders';
  }

  $init(): void {
    // Initialization logic if needed
  }
}


==== resources\js\Models\PurchaseOrderPart.ts ====

import { Model } from '@tailflow/laravel-orion/lib/model';
import { BelongsTo } from '@tailflow/laravel-orion/lib/drivers/default/relations/belongsTo';
import { Part } from './Part';
import { PurchaseOrder } from './PurchaseOrder';

export class PurchaseOrderPart extends Model<{
  id: number;
  purchase_order_id: number;
  part_id: number;
  quantity_ordered: number;
  unit_cost: number | null;
  total_cost: number | null;
  quantity_invoiced: number;
  quantity_received: number;
  status: string | null;
  notes: string | null;
  created_at: string;
  updated_at: string;
  part?: Part;
}> {
  static $keyName = 'id';

  $resource(): string {
    return 'purchase-order-parts';
  }

  purchaseOrder(): BelongsTo<PurchaseOrder> {
    return new BelongsTo(PurchaseOrder, this);
  }

  part(): BelongsTo<Part> {
    return new BelongsTo(Part, this);
  }

  calculateTotalCost(): void {
    this.$attributes.total_cost = this.$attributes.quantity_ordered * (this.$attributes.unit_cost || 0);
  }

  static includes(): string[] {
    return ['purchaseOrder', 'part'];
  }

  static filterableBy(): string[] {
    return [
      'id',
      'purchase_order_id',
      'part_id',
      'quantity_ordered',
      'unit_cost',
      'total_cost',
      'quantity_invoiced',
      'quantity_received',
      'status',
    ];
  }

  static sortableBy(): string[] {
    return [
      'id',
      'quantity_ordered',
      'unit_cost',
      'total_cost',
      'quantity_invoiced',
      'quantity_received',
      'status',
    ];
  }

  static searchableBy(): string[] {
    return ['notes'];
  }

  $init(): void {
    // Initialization logic if needed
  }
}


==== resources\js\Models\Supplier.ts ====

import { Model } from '@tailflow/laravel-orion/lib/model';
import { HasMany } from '@tailflow/laravel-orion/lib/drivers/default/relations/hasMany';
import { Part } from './Part';
import { Location } from './Location';

export class Supplier extends Model {
  $resource(): string {
    return 'suppliers';
  }

  // Properties
  id!: number;
  name!: string;
  account_number!: string;
  payment_terms!: string;
  lead_time_days!: number;
  free_shipping_threshold_usd!: number;
  addresses: any;
  contact: any;
  created_at!: string;
  updated_at!: string;
  deleted_at: string | null = null;

  // Relationships
  parts(): HasMany<Part> {
    return this.hasMany(Part);
  }

  locations(): HasMany<Location> {
    return this.hasMany(Location);
  }
}


==== resources\js\Models\types.ts ====

export namespace App.DTOs {
  export type AddressDTO = {
    address1: string | null;
    address2: string | null;
    city: string | null;
    state_prov_code: string | null;
    zip: string | null;
    phone_number: string | null;
    email_address: string | null;
  };

  export type IdentifierDTO = {
    identifiers: Array<any>;
  };

  export type IdentifierData = {
    type: string | null;
    value: string | null;
  };

  export type LocationAddressesDTO = {
    billTo: any | null;
    shipFrom: any | null;
    shipTo: any | null;
    other: any | null;
  };

  export type ReplenishmentDataDTO = {
    lead_days: number;
    purchaseTerms: Array<any>;
  };

  export type SupplierAddressesDTO = {
    billTo: any | null;
    shipFrom: any | null;
    shipTo: any | null;
    returnTo: any | null;
  };
}

export namespace App.Enums {
  export type DimensionType = 'box' | 'pallet' | 'individual_unit' | 'product' | 'packaging';
  export type InventoryQuantityType = 'quantity_onhand' | 'quantity_allocated' | 'quantity_backordered' | 'quantity_reserved' | 'quantity_intransit';
  export type PurchaseOrderStatus = 'draft' | 'submitted' | 'approved' | 'partially_received' | 'fully_received' | 'closed' | 'cancelled';
}

export namespace App.Enums.Replenishment {
  export type RecommendedAction = 'None' | 'Reorder' | 'Restock' | 'Hold';
}

export namespace App.InventoryTransactions.Enums {
  export type TransactionSourceType = 'purchase_order' | 'sales_order' | 'internal_transfer' | 'adjustment' | 'production' | 'return' | 'cycle_count';
  export type TransactionType = 'adjustment' | 'transfer' | 'receipt' | 'issue' | 'return' | 'cycle_count' | 'allocate' | 'reserve' | 'backorder';
}


==== resources\js\Models\User.ts ====

import { Model } from '@tailflow/laravel-orion/lib/model';

export class User extends Model<{
  id: number;
  name: string;
  email: string;
  email_verified_at?: string;
}> {
  $resource(): string {
    return 'users';
  }

  static includes(): string[] {
    return [];
  }

  static filterableBy(): string[] {
    return ['id', 'name', 'email', 'email_verified_at'];
  }

  static sortableBy(): string[] {
    return ['id', 'name', 'email', 'email_verified_at'];
  }

  static searchableBy(): string[] {
    return ['name', 'email'];
  }
}


==== resources\js\Pages\CreatePurchaseOrderByPart.php ====

<script setup>
    import AuthenticatedLayout from '@/Layouts/AuthenticatedLayout.vue';
    import Container from '@/Components/Container.vue';
    import ResponsiveCard from '@/Components/ResponsiveCard.vue';
    import CreatePurchaseOrder from './PurchaseOrders/CreatePurchaseOrder.vue';
</script>

<template>

    <Head title="Dashboard" />
    <AuthenticatedLayout>
        <template #header>
            <h2 class="font-bold text-xl leading-tight">Create Purchase Order</h2>
            <h4 class="text-md leading-tight">by Part</h4>
        </template>
        <Container :spaced-mobile="false">
            <div class="py-12">
                <ResponsiveCard>
                    <CreatePurchaseOrder />
                </ResponsiveCard>
            </div>
        </Container>
    </AuthenticatedLayout>
</template>

==== resources\js\Stores\locationStore.ts ====

import { defineStore } from 'pinia';
import { ref } from 'vue';
import { Location } from '../Models/Location';
import axios from 'axios';

export const useLocationStore = defineStore('location', () => {
  const locations = ref<Location[]>([]);
  const loading = ref(false);
  const error = ref<string | null>(null);

  async function fetchWarehouseLocations() {
    loading.value = true;
    error.value = null;
    try {
      const response = await axios.get('/api/locations', {
        params: { type: 'warehouse' }
      });
      locations.value = response.data.data.map((item: any) => new Location(item));
    } catch (err) {
      console.error('Failed to fetch warehouse locations:', err);
      error.value = 'Failed to fetch warehouse locations';
    } finally {
      loading.value = false;
    }
  }

  return {
    locations,
    loading,
    error,
    fetchWarehouseLocations,
  };
});


==== resources\js\Stores\partStore.ts ====

import { defineStore } from 'pinia';
import { Part } from '@/Models/Part';
import api from '../api';

export const usePartStore = defineStore('part', {
  state: () => ({
    parts: [] as Part[],
    loading: false,
    error: null as string | null,
  }),
  getters: {
    getParts: (state) => state.parts,
    getLoading: (state) => state.loading,
    getError: (state) => state.error,
  },
  actions: {
    async fetchPartsBySupplier(supplierId: number) {
      this.loading = true;
      this.error = null;
      try {
        const response = await api.get(`/parts`, {
          params: { filter: { supplier_id: supplierId } }
        });
        this.parts = response.data.data.map((item: any) => new Part(item));
      } catch (error: any) {
        console.error('Error fetching parts:', error);
        this.error = error.message || 'An error occurred while fetching parts';
      } finally {
        this.loading = false;
      }
    },
    async fetchParts() {
      this.loading = true;
      this.error = null;
      try {
        const response = await api.get('/parts');
        this.parts = response.data.data.map((item: any) => new Part(item));
      } catch (error: any) {
        console.error('Error fetching parts:', error);
        this.error = error.message || 'An error occurred while fetching parts';
      } finally {
        this.loading = false;
      }
    },
    async createPart(partData: Partial<Part>) {
      this.loading = true;
      this.error = null;
      try {
        const response = await api.post('/parts', partData);
        const newPart = new Part(response.data.data);
        this.parts.push(newPart);
        return newPart;
      } catch (error: any) {
        console.error('Error creating part:', error);
        this.error = error.message || 'An error occurred while creating the part';
        throw error;
      } finally {
        this.loading = false;
      }
    },
    async updatePart(partId: number, partData: Partial<Part>) {
      this.loading = true;
      this.error = null;
      try {
        const response = await api.put(`/parts/${partId}`, partData);
        const updatedPart = new Part(response.data.data);
        const index = this.parts.findIndex(p => p.id === partId);
        if (index !== -1) {
          this.parts[index] = updatedPart;
        }
        return updatedPart;
      } catch (error: any) {
        console.error('Error updating part:', error);
        this.error = error.message || 'An error occurred while updating the part';
        throw error;
      } finally {
        this.loading = false;
      }
    },
    async deletePart(partId: number) {
      this.loading = true;
      this.error = null;
      try {
        await api.delete(`/parts/${partId}`);
        this.parts = this.parts.filter(p => p.id !== partId);
      } catch (error: any) {
        console.error('Error deleting part:', error);
        this.error = error.message || 'An error occurred while deleting the part';
        throw error;
      } finally {
        this.loading = false;
      }
    },
  },
});


==== resources\js\Stores\purchaseOrderStore.ts ====

import { defineStore } from 'pinia';
import { PurchaseOrder } from '../Models/PurchaseOrder';
import { PurchaseOrderPart } from '../Models/PurchaseOrderPart';
import { Supplier } from '../Models/Supplier';
import { Location } from '../Models/Location';
import { AddressDTO } from '../Interfaces/AddressDTO';
import { Part } from '../Models/Part';
import api from '../api';

export const usePurchaseOrderStore = defineStore('purchaseOrder', {
  state: () => ({
    purchaseOrder: null as PurchaseOrder | null,
    purchaseOrderParts: [] as PurchaseOrderPart[],
    supplier: null as Supplier | null,
    locations: {
      billTo: null as Location | null,
      shipFrom: null as Location | null,
      shipTo: null as Location | null,
    },
    addresses: {
      billTo: null as AddressDTO | null,
      shipFrom: null as AddressDTO | null,
      shipTo: null as AddressDTO | null,
    },
    loading: false,
    error: null as string | null,
  }),

  getters: {
    subtotal: (state) => {
      return state.purchaseOrderParts.reduce((total, part) => total + (part.$attributes.total_cost || 0), 0);
    },
    taxAmount: (state) => {
      // Assuming a fixed tax rate of 10% for this example
      const taxRate = 0.1;
      return state.purchaseOrderParts.reduce((total, part) => total + (part.$attributes.total_cost || 0), 0) * taxRate;
    },
    total: (state) => {
      const subtotal = state.purchaseOrderParts.reduce((total, part) => total + (part.$attributes.total_cost || 0), 0);
      const taxRate = 0.1;
      return subtotal + (subtotal * taxRate);
    },
  },

  actions: {
    setSupplier(supplier: Supplier) {
      this.supplier = supplier;
    },

    setLocation(locationType: 'billTo' | 'shipFrom' | 'shipTo', location: Location) {
      this.locations[locationType] = location;
    },

    setAddress(addressType: 'billTo' | 'shipFrom' | 'shipTo', address: AddressDTO) {
      this.addresses[addressType] = address;
    },

    updatePurchaseOrderParts(parts: Part[]) {
      this.purchaseOrderParts = parts.map(part => new PurchaseOrderPart({
        purchase_order_id: this.purchaseOrder?.$attributes.id,
        part_id: part.$attributes.id,
        quantity_ordered: 0,
        unit_cost: 0,
        total_cost: 0,
        quantity_invoiced: 0,
        quantity_received: 0,
        status: null,
        notes: null,
        part: part,
      }));
    },

    updatePurchaseOrderPart(updatedPart: PurchaseOrderPart) {
      const index = this.purchaseOrderParts.findIndex(p => p.$attributes.id === updatedPart.$attributes.id);
      if (index !== -1) {
        this.purchaseOrderParts[index] = updatedPart;
      }
    },

    calculateTotals() {
      this.purchaseOrderParts.forEach(part => {
        part.$attributes.total_cost = part.$attributes.quantity_ordered * (part.$attributes.unit_cost || 0);
      });
    },

    async submitPurchaseOrder() {
      this.loading = true;
      this.error = null;
      try {
        if (!this.purchaseOrder) {
          throw new Error('Purchase order is not initialized');
        }

        const orderData = {
          ...this.purchaseOrder.$attributes,
          supplier_id: this.supplier?.$attributes.id,
          bill_to_location_id: this.locations.billTo?.$attributes.id,
          ship_from_location_id: this.locations.shipFrom?.$attributes.id,
          ship_to_location_id: this.locations.shipTo?.$attributes.id,
          bill_to_address: this.addresses.billTo,
          ship_from_address: this.addresses.shipFrom,
          ship_to_address: this.addresses.shipTo,
          total_cost: this.total,
          status: 'submitted',
          purchase_order_parts: this.purchaseOrderParts.map(part => part.$attributes),
        };

        const response = await api.post('/purchase-orders', orderData);
        const newOrder = new PurchaseOrder(response.data);
        this.purchaseOrder = newOrder;
        return newOrder;
      } catch (error: any) {
        console.error('Error submitting purchase order:', error);
        this.error = error.message || 'An error occurred while submitting the purchase order';
        throw error;
      } finally {
        this.loading = false;
      }
    },

    resetStore() {
      this.purchaseOrder = null;
      this.purchaseOrderParts = [];
      this.supplier = null;
      this.locations = {
        billTo: null,
        shipFrom: null,
        shipTo: null,
      };
      this.addresses = {
        billTo: null,
        shipFrom: null,
        shipTo: null,
      };
      this.loading = false;
      this.error = null;
    },
  },
});


==== resources\js\Stores\supplierStore.ts ====

import { defineStore } from 'pinia';
import { Supplier } from '@/Models/Supplier';
import api from '../api';

export const useSupplierStore = defineStore('supplier', {
  state: () => ({
    suppliers: [] as Supplier[],
    loading: false,
    error: null as string | null,
  }),
  getters: {
    getSuppliers: (state) => state.suppliers,
    getLoading: (state) => state.loading,
    getError: (state) => state.error,
  },
  actions: {
    async fetchSuppliers() {
      this.loading = true;
      this.error = null;
      try {
        const response = await api.get('/suppliers');
        this.suppliers = response.data.data.map((item: any) => new Supplier(item));
      } catch (error: any) {
        console.error('Error fetching suppliers:', error);
        this.error = error.message || 'An error occurred while fetching suppliers';
      } finally {
        this.loading = false;
      }
    },
    async createSupplier(supplierData: Partial<Supplier>) {
      this.loading = true;
      this.error = null;
      try {
        const response = await api.post('/suppliers', supplierData);
        const newSupplier = new Supplier(response.data.data);
        this.suppliers.push(newSupplier);
        return newSupplier;
      } catch (error: any) {
        console.error('Error creating supplier:', error);
        this.error = error.message || 'An error occurred while creating the supplier';
        throw error;
      } finally {
        this.loading = false;
      }
    },
    async updateSupplier(supplierId: number, supplierData: Partial<Supplier>) {
      this.loading = true;
      this.error = null;
      try {
        const response = await api.put(`/suppliers/${supplierId}`, supplierData);
        const updatedSupplier = new Supplier(response.data.data);
        const index = this.suppliers.findIndex(s => s.id === supplierId);
        if (index !== -1) {
          this.suppliers[index] = updatedSupplier;
        }
        return updatedSupplier;
      } catch (error: any) {
        console.error('Error updating supplier:', error);
        this.error = error.message || 'An error occurred while updating the supplier';
        throw error;
      } finally {
        this.loading = false;
      }
    },
    async deleteSupplier(supplierId: number) {
      this.loading = true;
      this.error = null;
      try {
        await api.delete(`/suppliers/${supplierId}`);
        this.suppliers = this.suppliers.filter(s => s.id !== supplierId);
      } catch (error: any) {
        console.error('Error deleting supplier:', error);
        this.error = error.message || 'An error occurred while deleting the supplier';
        throw error;
      } finally {
        this.loading = false;
      }
    },
  },
});


==== resources\js\api.ts ====

import axios from 'axios';

const api = axios.create({
  baseURL: '/api', // Assuming your API is served from the /api route
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
  },
});

export default api;


==== resources\js\app.js ====

import './bootstrap';
import '../css/app.css';
import 'primeicons/primeicons.css';

import { createApp, h } from 'vue';
import { createInertiaApp, Head, Link } from '@inertiajs/vue3';
import { resolvePageComponent } from 'laravel-vite-plugin/inertia-helpers';
import { ZiggyVue } from '../../vendor/tightenco/ziggy';

import { createPinia } from 'pinia';
import { purchaseOrderPlugin } from './Plugins/purchaseOrderPlugin';

import PrimeVue from 'primevue/config';
import ToastService from 'primevue/toastservice';
import InputText from 'primevue/inputtext';
import Button from 'primevue/button';
import Core from 'primevue/config'
import IftaLabel from 'primevue/iftalabel';
import FileUpload from 'primevue/fileupload'
import Steps from 'primevue/steps'


import { useTheme } from './Composables/useTheme.js';
import customThemePreset from './theme-preset.js';
// Import Orion SDK
import { Orion } from "@tailflow/laravel-orion/lib/orion";

const appName = import.meta.env.VITE_APP_NAME || 'Laravel';

// Initialize Orion SDK
Orion.init(window.location.origin);

const pinia = createPinia();
pinia.use(purchaseOrderPlugin);

createInertiaApp({
    title: (title) => `${title} - ${appName}`,
    resolve: (name) =>
        resolvePageComponent(
            `./Pages/${name}.vue`,
            import.meta.glob('./Pages/**/*.vue')
        ),
    setup({ el, App, props, plugin }) {
        // set site theme (light/dark mode)
        const { initSiteTheme } = useTheme();
        initSiteTheme();

        // start the app
        return createApp({ render: () => h(App, props) })
            .use(plugin)
            .use(pinia)
            .use(ZiggyVue, Ziggy)
            .use(PrimeVue, {
                theme: customThemePreset,
            })
            .component('FileUpload', FileUpload)
            .component('Steps', Steps)
            .component('Button', Button)
            .use(ToastService)
            .component('Head', Head)
            .component('Link', Link)
            .component('InputText', InputText)
            .component('IftaLabel', IftaLabel)
            .component('Core', Core)
            .mount(el);
    },
    progress: {
        color: 'var(--p-primary-500)',
    },
});
